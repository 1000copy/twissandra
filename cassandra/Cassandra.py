#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

from thrift.Thrift import *
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface:
  def get_slice(self, tablename, key, columnParent, start, count):
    """
    Parameters:
     - tablename
     - key
     - columnParent
     - start
     - count
    """
    pass

  def get_slice_by_name_range(self, tablename, key, columnParent, start, end, count):
    """
    Parameters:
     - tablename
     - key
     - columnParent
     - start
     - end
     - count
    """
    pass

  def get_slice_by_names(self, tablename, key, columnParent, columnNames):
    """
    Parameters:
     - tablename
     - key
     - columnParent
     - columnNames
    """
    pass

  def get_slice_from(self, tablename, key, columnParent, isAscending, count):
    """
    Parameters:
     - tablename
     - key
     - columnParent
     - isAscending
     - count
    """
    pass

  def get_column(self, tablename, key, columnPath):
    """
    Parameters:
     - tablename
     - key
     - columnPath
    """
    pass

  def get_column_count(self, tablename, key, columnParent):
    """
    Parameters:
     - tablename
     - key
     - columnParent
    """
    pass

  def insert(self, tablename, key, columnPath, cellData, timestamp, block_for):
    """
    Parameters:
     - tablename
     - key
     - columnPath
     - cellData
     - timestamp
     - block_for
    """
    pass

  def batch_insert(self, batchMutation, block_for):
    """
    Parameters:
     - batchMutation
     - block_for
    """
    pass

  def remove(self, tablename, key, columnPathOrParent, timestamp, block_for):
    """
    Parameters:
     - tablename
     - key
     - columnPathOrParent
     - timestamp
     - block_for
    """
    pass

  def get_columns_since(self, tablename, key, columnParent, timeStamp):
    """
    Parameters:
     - tablename
     - key
     - columnParent
     - timeStamp
    """
    pass

  def get_slice_super(self, tablename, key, columnFamily, start, count):
    """
    Parameters:
     - tablename
     - key
     - columnFamily
     - start
     - count
    """
    pass

  def get_slice_super_by_names(self, tablename, key, columnFamily, superColumnNames):
    """
    Parameters:
     - tablename
     - key
     - columnFamily
     - superColumnNames
    """
    pass

  def get_superColumn(self, tablename, key, superColumnPath):
    """
    Parameters:
     - tablename
     - key
     - superColumnPath
    """
    pass

  def batch_insert_superColumn(self, batchMutationSuper, block_for):
    """
    Parameters:
     - batchMutationSuper
     - block_for
    """
    pass

  def get_key_range(self, tablename, columnFamilies, startWith, stopAt, maxResults):
    """
    Parameters:
     - tablename
     - columnFamilies
     - startWith
     - stopAt
     - maxResults
    """
    pass

  def getStringProperty(self, propertyName):
    """
    Parameters:
     - propertyName
    """
    pass

  def getStringListProperty(self, propertyName):
    """
    Parameters:
     - propertyName
    """
    pass

  def describeTable(self, tableName):
    """
    Parameters:
     - tableName
    """
    pass

  def executeQuery(self, query):
    """
    Parameters:
     - query
    """
    pass


class Client(Iface):
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot != None:
      self._oprot = oprot
    self._seqid = 0

  def get_slice(self, tablename, key, columnParent, start, count):
    """
    Parameters:
     - tablename
     - key
     - columnParent
     - start
     - count
    """
    self.send_get_slice(tablename, key, columnParent, start, count)
    return self.recv_get_slice()

  def send_get_slice(self, tablename, key, columnParent, start, count):
    self._oprot.writeMessageBegin('get_slice', TMessageType.CALL, self._seqid)
    args = get_slice_args()
    args.tablename = tablename
    args.key = key
    args.columnParent = columnParent
    args.start = start
    args.count = count
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_slice(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_slice_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.ire != None:
      raise result.ire
    if result.nfe != None:
      raise result.nfe
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_slice failed: unknown result");

  def get_slice_by_name_range(self, tablename, key, columnParent, start, end, count):
    """
    Parameters:
     - tablename
     - key
     - columnParent
     - start
     - end
     - count
    """
    self.send_get_slice_by_name_range(tablename, key, columnParent, start, end, count)
    return self.recv_get_slice_by_name_range()

  def send_get_slice_by_name_range(self, tablename, key, columnParent, start, end, count):
    self._oprot.writeMessageBegin('get_slice_by_name_range', TMessageType.CALL, self._seqid)
    args = get_slice_by_name_range_args()
    args.tablename = tablename
    args.key = key
    args.columnParent = columnParent
    args.start = start
    args.end = end
    args.count = count
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_slice_by_name_range(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_slice_by_name_range_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.ire != None:
      raise result.ire
    if result.nfe != None:
      raise result.nfe
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_slice_by_name_range failed: unknown result");

  def get_slice_by_names(self, tablename, key, columnParent, columnNames):
    """
    Parameters:
     - tablename
     - key
     - columnParent
     - columnNames
    """
    self.send_get_slice_by_names(tablename, key, columnParent, columnNames)
    return self.recv_get_slice_by_names()

  def send_get_slice_by_names(self, tablename, key, columnParent, columnNames):
    self._oprot.writeMessageBegin('get_slice_by_names', TMessageType.CALL, self._seqid)
    args = get_slice_by_names_args()
    args.tablename = tablename
    args.key = key
    args.columnParent = columnParent
    args.columnNames = columnNames
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_slice_by_names(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_slice_by_names_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.ire != None:
      raise result.ire
    if result.nfe != None:
      raise result.nfe
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_slice_by_names failed: unknown result");

  def get_slice_from(self, tablename, key, columnParent, isAscending, count):
    """
    Parameters:
     - tablename
     - key
     - columnParent
     - isAscending
     - count
    """
    self.send_get_slice_from(tablename, key, columnParent, isAscending, count)
    return self.recv_get_slice_from()

  def send_get_slice_from(self, tablename, key, columnParent, isAscending, count):
    self._oprot.writeMessageBegin('get_slice_from', TMessageType.CALL, self._seqid)
    args = get_slice_from_args()
    args.tablename = tablename
    args.key = key
    args.columnParent = columnParent
    args.isAscending = isAscending
    args.count = count
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_slice_from(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_slice_from_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.ire != None:
      raise result.ire
    if result.nfe != None:
      raise result.nfe
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_slice_from failed: unknown result");

  def get_column(self, tablename, key, columnPath):
    """
    Parameters:
     - tablename
     - key
     - columnPath
    """
    self.send_get_column(tablename, key, columnPath)
    return self.recv_get_column()

  def send_get_column(self, tablename, key, columnPath):
    self._oprot.writeMessageBegin('get_column', TMessageType.CALL, self._seqid)
    args = get_column_args()
    args.tablename = tablename
    args.key = key
    args.columnPath = columnPath
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_column(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_column_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.ire != None:
      raise result.ire
    if result.nfe != None:
      raise result.nfe
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_column failed: unknown result");

  def get_column_count(self, tablename, key, columnParent):
    """
    Parameters:
     - tablename
     - key
     - columnParent
    """
    self.send_get_column_count(tablename, key, columnParent)
    return self.recv_get_column_count()

  def send_get_column_count(self, tablename, key, columnParent):
    self._oprot.writeMessageBegin('get_column_count', TMessageType.CALL, self._seqid)
    args = get_column_count_args()
    args.tablename = tablename
    args.key = key
    args.columnParent = columnParent
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_column_count(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_column_count_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.ire != None:
      raise result.ire
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_column_count failed: unknown result");

  def insert(self, tablename, key, columnPath, cellData, timestamp, block_for):
    """
    Parameters:
     - tablename
     - key
     - columnPath
     - cellData
     - timestamp
     - block_for
    """
    self.send_insert(tablename, key, columnPath, cellData, timestamp, block_for)
    self.recv_insert()

  def send_insert(self, tablename, key, columnPath, cellData, timestamp, block_for):
    self._oprot.writeMessageBegin('insert', TMessageType.CALL, self._seqid)
    args = insert_args()
    args.tablename = tablename
    args.key = key
    args.columnPath = columnPath
    args.cellData = cellData
    args.timestamp = timestamp
    args.block_for = block_for
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_insert(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = insert_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.ire != None:
      raise result.ire
    if result.ue != None:
      raise result.ue
    return

  def batch_insert(self, batchMutation, block_for):
    """
    Parameters:
     - batchMutation
     - block_for
    """
    self.send_batch_insert(batchMutation, block_for)
    self.recv_batch_insert()

  def send_batch_insert(self, batchMutation, block_for):
    self._oprot.writeMessageBegin('batch_insert', TMessageType.CALL, self._seqid)
    args = batch_insert_args()
    args.batchMutation = batchMutation
    args.block_for = block_for
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_batch_insert(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = batch_insert_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.ire != None:
      raise result.ire
    if result.ue != None:
      raise result.ue
    return

  def remove(self, tablename, key, columnPathOrParent, timestamp, block_for):
    """
    Parameters:
     - tablename
     - key
     - columnPathOrParent
     - timestamp
     - block_for
    """
    self.send_remove(tablename, key, columnPathOrParent, timestamp, block_for)
    self.recv_remove()

  def send_remove(self, tablename, key, columnPathOrParent, timestamp, block_for):
    self._oprot.writeMessageBegin('remove', TMessageType.CALL, self._seqid)
    args = remove_args()
    args.tablename = tablename
    args.key = key
    args.columnPathOrParent = columnPathOrParent
    args.timestamp = timestamp
    args.block_for = block_for
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_remove(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = remove_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.ire != None:
      raise result.ire
    if result.ue != None:
      raise result.ue
    return

  def get_columns_since(self, tablename, key, columnParent, timeStamp):
    """
    Parameters:
     - tablename
     - key
     - columnParent
     - timeStamp
    """
    self.send_get_columns_since(tablename, key, columnParent, timeStamp)
    return self.recv_get_columns_since()

  def send_get_columns_since(self, tablename, key, columnParent, timeStamp):
    self._oprot.writeMessageBegin('get_columns_since', TMessageType.CALL, self._seqid)
    args = get_columns_since_args()
    args.tablename = tablename
    args.key = key
    args.columnParent = columnParent
    args.timeStamp = timeStamp
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_columns_since(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_columns_since_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.ire != None:
      raise result.ire
    if result.nfe != None:
      raise result.nfe
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_columns_since failed: unknown result");

  def get_slice_super(self, tablename, key, columnFamily, start, count):
    """
    Parameters:
     - tablename
     - key
     - columnFamily
     - start
     - count
    """
    self.send_get_slice_super(tablename, key, columnFamily, start, count)
    return self.recv_get_slice_super()

  def send_get_slice_super(self, tablename, key, columnFamily, start, count):
    self._oprot.writeMessageBegin('get_slice_super', TMessageType.CALL, self._seqid)
    args = get_slice_super_args()
    args.tablename = tablename
    args.key = key
    args.columnFamily = columnFamily
    args.start = start
    args.count = count
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_slice_super(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_slice_super_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.ire != None:
      raise result.ire
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_slice_super failed: unknown result");

  def get_slice_super_by_names(self, tablename, key, columnFamily, superColumnNames):
    """
    Parameters:
     - tablename
     - key
     - columnFamily
     - superColumnNames
    """
    self.send_get_slice_super_by_names(tablename, key, columnFamily, superColumnNames)
    return self.recv_get_slice_super_by_names()

  def send_get_slice_super_by_names(self, tablename, key, columnFamily, superColumnNames):
    self._oprot.writeMessageBegin('get_slice_super_by_names', TMessageType.CALL, self._seqid)
    args = get_slice_super_by_names_args()
    args.tablename = tablename
    args.key = key
    args.columnFamily = columnFamily
    args.superColumnNames = superColumnNames
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_slice_super_by_names(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_slice_super_by_names_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.ire != None:
      raise result.ire
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_slice_super_by_names failed: unknown result");

  def get_superColumn(self, tablename, key, superColumnPath):
    """
    Parameters:
     - tablename
     - key
     - superColumnPath
    """
    self.send_get_superColumn(tablename, key, superColumnPath)
    return self.recv_get_superColumn()

  def send_get_superColumn(self, tablename, key, superColumnPath):
    self._oprot.writeMessageBegin('get_superColumn', TMessageType.CALL, self._seqid)
    args = get_superColumn_args()
    args.tablename = tablename
    args.key = key
    args.superColumnPath = superColumnPath
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_superColumn(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_superColumn_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.ire != None:
      raise result.ire
    if result.nfe != None:
      raise result.nfe
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_superColumn failed: unknown result");

  def batch_insert_superColumn(self, batchMutationSuper, block_for):
    """
    Parameters:
     - batchMutationSuper
     - block_for
    """
    self.send_batch_insert_superColumn(batchMutationSuper, block_for)
    self.recv_batch_insert_superColumn()

  def send_batch_insert_superColumn(self, batchMutationSuper, block_for):
    self._oprot.writeMessageBegin('batch_insert_superColumn', TMessageType.CALL, self._seqid)
    args = batch_insert_superColumn_args()
    args.batchMutationSuper = batchMutationSuper
    args.block_for = block_for
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_batch_insert_superColumn(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = batch_insert_superColumn_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.ire != None:
      raise result.ire
    if result.ue != None:
      raise result.ue
    return

  def get_key_range(self, tablename, columnFamilies, startWith, stopAt, maxResults):
    """
    Parameters:
     - tablename
     - columnFamilies
     - startWith
     - stopAt
     - maxResults
    """
    self.send_get_key_range(tablename, columnFamilies, startWith, stopAt, maxResults)
    return self.recv_get_key_range()

  def send_get_key_range(self, tablename, columnFamilies, startWith, stopAt, maxResults):
    self._oprot.writeMessageBegin('get_key_range', TMessageType.CALL, self._seqid)
    args = get_key_range_args()
    args.tablename = tablename
    args.columnFamilies = columnFamilies
    args.startWith = startWith
    args.stopAt = stopAt
    args.maxResults = maxResults
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_key_range(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_key_range_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.ire != None:
      raise result.ire
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_key_range failed: unknown result");

  def getStringProperty(self, propertyName):
    """
    Parameters:
     - propertyName
    """
    self.send_getStringProperty(propertyName)
    return self.recv_getStringProperty()

  def send_getStringProperty(self, propertyName):
    self._oprot.writeMessageBegin('getStringProperty', TMessageType.CALL, self._seqid)
    args = getStringProperty_args()
    args.propertyName = propertyName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getStringProperty(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getStringProperty_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getStringProperty failed: unknown result");

  def getStringListProperty(self, propertyName):
    """
    Parameters:
     - propertyName
    """
    self.send_getStringListProperty(propertyName)
    return self.recv_getStringListProperty()

  def send_getStringListProperty(self, propertyName):
    self._oprot.writeMessageBegin('getStringListProperty', TMessageType.CALL, self._seqid)
    args = getStringListProperty_args()
    args.propertyName = propertyName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getStringListProperty(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getStringListProperty_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getStringListProperty failed: unknown result");

  def describeTable(self, tableName):
    """
    Parameters:
     - tableName
    """
    self.send_describeTable(tableName)
    return self.recv_describeTable()

  def send_describeTable(self, tableName):
    self._oprot.writeMessageBegin('describeTable', TMessageType.CALL, self._seqid)
    args = describeTable_args()
    args.tableName = tableName
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_describeTable(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = describeTable_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "describeTable failed: unknown result");

  def executeQuery(self, query):
    """
    Parameters:
     - query
    """
    self.send_executeQuery(query)
    return self.recv_executeQuery()

  def send_executeQuery(self, query):
    self._oprot.writeMessageBegin('executeQuery', TMessageType.CALL, self._seqid)
    args = executeQuery_args()
    args.query = query
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_executeQuery(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = executeQuery_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "executeQuery failed: unknown result");


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["get_slice"] = Processor.process_get_slice
    self._processMap["get_slice_by_name_range"] = Processor.process_get_slice_by_name_range
    self._processMap["get_slice_by_names"] = Processor.process_get_slice_by_names
    self._processMap["get_slice_from"] = Processor.process_get_slice_from
    self._processMap["get_column"] = Processor.process_get_column
    self._processMap["get_column_count"] = Processor.process_get_column_count
    self._processMap["insert"] = Processor.process_insert
    self._processMap["batch_insert"] = Processor.process_batch_insert
    self._processMap["remove"] = Processor.process_remove
    self._processMap["get_columns_since"] = Processor.process_get_columns_since
    self._processMap["get_slice_super"] = Processor.process_get_slice_super
    self._processMap["get_slice_super_by_names"] = Processor.process_get_slice_super_by_names
    self._processMap["get_superColumn"] = Processor.process_get_superColumn
    self._processMap["batch_insert_superColumn"] = Processor.process_batch_insert_superColumn
    self._processMap["get_key_range"] = Processor.process_get_key_range
    self._processMap["getStringProperty"] = Processor.process_getStringProperty
    self._processMap["getStringListProperty"] = Processor.process_getStringListProperty
    self._processMap["describeTable"] = Processor.process_describeTable
    self._processMap["executeQuery"] = Processor.process_executeQuery

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_get_slice(self, seqid, iprot, oprot):
    args = get_slice_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_slice_result()
    try:
      result.success = self._handler.get_slice(args.tablename, args.key, args.columnParent, args.start, args.count)
    except InvalidRequestException, ire:
      result.ire = ire
    except NotFoundException, nfe:
      result.nfe = nfe
    oprot.writeMessageBegin("get_slice", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_slice_by_name_range(self, seqid, iprot, oprot):
    args = get_slice_by_name_range_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_slice_by_name_range_result()
    try:
      result.success = self._handler.get_slice_by_name_range(args.tablename, args.key, args.columnParent, args.start, args.end, args.count)
    except InvalidRequestException, ire:
      result.ire = ire
    except NotFoundException, nfe:
      result.nfe = nfe
    oprot.writeMessageBegin("get_slice_by_name_range", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_slice_by_names(self, seqid, iprot, oprot):
    args = get_slice_by_names_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_slice_by_names_result()
    try:
      result.success = self._handler.get_slice_by_names(args.tablename, args.key, args.columnParent, args.columnNames)
    except InvalidRequestException, ire:
      result.ire = ire
    except NotFoundException, nfe:
      result.nfe = nfe
    oprot.writeMessageBegin("get_slice_by_names", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_slice_from(self, seqid, iprot, oprot):
    args = get_slice_from_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_slice_from_result()
    try:
      result.success = self._handler.get_slice_from(args.tablename, args.key, args.columnParent, args.isAscending, args.count)
    except InvalidRequestException, ire:
      result.ire = ire
    except NotFoundException, nfe:
      result.nfe = nfe
    oprot.writeMessageBegin("get_slice_from", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_column(self, seqid, iprot, oprot):
    args = get_column_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_column_result()
    try:
      result.success = self._handler.get_column(args.tablename, args.key, args.columnPath)
    except InvalidRequestException, ire:
      result.ire = ire
    except NotFoundException, nfe:
      result.nfe = nfe
    oprot.writeMessageBegin("get_column", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_column_count(self, seqid, iprot, oprot):
    args = get_column_count_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_column_count_result()
    try:
      result.success = self._handler.get_column_count(args.tablename, args.key, args.columnParent)
    except InvalidRequestException, ire:
      result.ire = ire
    oprot.writeMessageBegin("get_column_count", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_insert(self, seqid, iprot, oprot):
    args = insert_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = insert_result()
    try:
      self._handler.insert(args.tablename, args.key, args.columnPath, args.cellData, args.timestamp, args.block_for)
    except InvalidRequestException, ire:
      result.ire = ire
    except UnavailableException, ue:
      result.ue = ue
    oprot.writeMessageBegin("insert", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_batch_insert(self, seqid, iprot, oprot):
    args = batch_insert_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = batch_insert_result()
    try:
      self._handler.batch_insert(args.batchMutation, args.block_for)
    except InvalidRequestException, ire:
      result.ire = ire
    except UnavailableException, ue:
      result.ue = ue
    oprot.writeMessageBegin("batch_insert", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_remove(self, seqid, iprot, oprot):
    args = remove_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = remove_result()
    try:
      self._handler.remove(args.tablename, args.key, args.columnPathOrParent, args.timestamp, args.block_for)
    except InvalidRequestException, ire:
      result.ire = ire
    except UnavailableException, ue:
      result.ue = ue
    oprot.writeMessageBegin("remove", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_columns_since(self, seqid, iprot, oprot):
    args = get_columns_since_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_columns_since_result()
    try:
      result.success = self._handler.get_columns_since(args.tablename, args.key, args.columnParent, args.timeStamp)
    except InvalidRequestException, ire:
      result.ire = ire
    except NotFoundException, nfe:
      result.nfe = nfe
    oprot.writeMessageBegin("get_columns_since", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_slice_super(self, seqid, iprot, oprot):
    args = get_slice_super_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_slice_super_result()
    try:
      result.success = self._handler.get_slice_super(args.tablename, args.key, args.columnFamily, args.start, args.count)
    except InvalidRequestException, ire:
      result.ire = ire
    oprot.writeMessageBegin("get_slice_super", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_slice_super_by_names(self, seqid, iprot, oprot):
    args = get_slice_super_by_names_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_slice_super_by_names_result()
    try:
      result.success = self._handler.get_slice_super_by_names(args.tablename, args.key, args.columnFamily, args.superColumnNames)
    except InvalidRequestException, ire:
      result.ire = ire
    oprot.writeMessageBegin("get_slice_super_by_names", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_superColumn(self, seqid, iprot, oprot):
    args = get_superColumn_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_superColumn_result()
    try:
      result.success = self._handler.get_superColumn(args.tablename, args.key, args.superColumnPath)
    except InvalidRequestException, ire:
      result.ire = ire
    except NotFoundException, nfe:
      result.nfe = nfe
    oprot.writeMessageBegin("get_superColumn", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_batch_insert_superColumn(self, seqid, iprot, oprot):
    args = batch_insert_superColumn_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = batch_insert_superColumn_result()
    try:
      self._handler.batch_insert_superColumn(args.batchMutationSuper, args.block_for)
    except InvalidRequestException, ire:
      result.ire = ire
    except UnavailableException, ue:
      result.ue = ue
    oprot.writeMessageBegin("batch_insert_superColumn", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_key_range(self, seqid, iprot, oprot):
    args = get_key_range_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_key_range_result()
    try:
      result.success = self._handler.get_key_range(args.tablename, args.columnFamilies, args.startWith, args.stopAt, args.maxResults)
    except InvalidRequestException, ire:
      result.ire = ire
    oprot.writeMessageBegin("get_key_range", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getStringProperty(self, seqid, iprot, oprot):
    args = getStringProperty_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getStringProperty_result()
    result.success = self._handler.getStringProperty(args.propertyName)
    oprot.writeMessageBegin("getStringProperty", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getStringListProperty(self, seqid, iprot, oprot):
    args = getStringListProperty_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getStringListProperty_result()
    result.success = self._handler.getStringListProperty(args.propertyName)
    oprot.writeMessageBegin("getStringListProperty", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_describeTable(self, seqid, iprot, oprot):
    args = describeTable_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = describeTable_result()
    result.success = self._handler.describeTable(args.tableName)
    oprot.writeMessageBegin("describeTable", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_executeQuery(self, seqid, iprot, oprot):
    args = executeQuery_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = executeQuery_result()
    result.success = self._handler.executeQuery(args.query)
    oprot.writeMessageBegin("executeQuery", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class get_slice_args(object):
  """
  Attributes:
   - tablename
   - key
   - columnParent
   - start
   - count
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tablename', None, None, ), # 1
    (2, TType.STRING, 'key', None, None, ), # 2
    (3, TType.STRING, 'columnParent', None, None, ), # 3
    (4, TType.I32, 'start', None, -1, ), # 4
    (5, TType.I32, 'count', None, -1, ), # 5
  )

  def __init__(self, tablename=None, key=None, columnParent=None, start=thrift_spec[4][4], count=thrift_spec[5][4],):
    self.tablename = tablename
    self.key = key
    self.columnParent = columnParent
    self.start = start
    self.count = count

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tablename = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.key = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.columnParent = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.start = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.count = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_slice_args')
    if self.tablename != None:
      oprot.writeFieldBegin('tablename', TType.STRING, 1)
      oprot.writeString(self.tablename)
      oprot.writeFieldEnd()
    if self.key != None:
      oprot.writeFieldBegin('key', TType.STRING, 2)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.columnParent != None:
      oprot.writeFieldBegin('columnParent', TType.STRING, 3)
      oprot.writeString(self.columnParent)
      oprot.writeFieldEnd()
    if self.start != None:
      oprot.writeFieldBegin('start', TType.I32, 4)
      oprot.writeI32(self.start)
      oprot.writeFieldEnd()
    if self.count != None:
      oprot.writeFieldBegin('count', TType.I32, 5)
      oprot.writeI32(self.count)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_slice_result(object):
  """
  Attributes:
   - success
   - ire
   - nfe
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(column_t, column_t.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ire', (InvalidRequestException, InvalidRequestException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'nfe', (NotFoundException, NotFoundException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ire=None, nfe=None,):
    self.success = success
    self.ire = ire
    self.nfe = nfe

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype58, _size55) = iprot.readListBegin()
          for _i59 in xrange(_size55):
            _elem60 = column_t()
            _elem60.read(iprot)
            self.success.append(_elem60)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ire = InvalidRequestException()
          self.ire.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.nfe = NotFoundException()
          self.nfe.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_slice_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter61 in self.success:
        iter61.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ire != None:
      oprot.writeFieldBegin('ire', TType.STRUCT, 1)
      self.ire.write(oprot)
      oprot.writeFieldEnd()
    if self.nfe != None:
      oprot.writeFieldBegin('nfe', TType.STRUCT, 2)
      self.nfe.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_slice_by_name_range_args(object):
  """
  Attributes:
   - tablename
   - key
   - columnParent
   - start
   - end
   - count
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tablename', None, None, ), # 1
    (2, TType.STRING, 'key', None, None, ), # 2
    (3, TType.STRING, 'columnParent', None, None, ), # 3
    (4, TType.STRING, 'start', None, None, ), # 4
    (5, TType.STRING, 'end', None, None, ), # 5
    (6, TType.I32, 'count', None, -1, ), # 6
  )

  def __init__(self, tablename=None, key=None, columnParent=None, start=None, end=None, count=thrift_spec[6][4],):
    self.tablename = tablename
    self.key = key
    self.columnParent = columnParent
    self.start = start
    self.end = end
    self.count = count

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tablename = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.key = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.columnParent = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.start = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.end = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.count = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_slice_by_name_range_args')
    if self.tablename != None:
      oprot.writeFieldBegin('tablename', TType.STRING, 1)
      oprot.writeString(self.tablename)
      oprot.writeFieldEnd()
    if self.key != None:
      oprot.writeFieldBegin('key', TType.STRING, 2)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.columnParent != None:
      oprot.writeFieldBegin('columnParent', TType.STRING, 3)
      oprot.writeString(self.columnParent)
      oprot.writeFieldEnd()
    if self.start != None:
      oprot.writeFieldBegin('start', TType.STRING, 4)
      oprot.writeString(self.start)
      oprot.writeFieldEnd()
    if self.end != None:
      oprot.writeFieldBegin('end', TType.STRING, 5)
      oprot.writeString(self.end)
      oprot.writeFieldEnd()
    if self.count != None:
      oprot.writeFieldBegin('count', TType.I32, 6)
      oprot.writeI32(self.count)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_slice_by_name_range_result(object):
  """
  Attributes:
   - success
   - ire
   - nfe
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(column_t, column_t.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ire', (InvalidRequestException, InvalidRequestException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'nfe', (NotFoundException, NotFoundException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ire=None, nfe=None,):
    self.success = success
    self.ire = ire
    self.nfe = nfe

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype65, _size62) = iprot.readListBegin()
          for _i66 in xrange(_size62):
            _elem67 = column_t()
            _elem67.read(iprot)
            self.success.append(_elem67)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ire = InvalidRequestException()
          self.ire.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.nfe = NotFoundException()
          self.nfe.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_slice_by_name_range_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter68 in self.success:
        iter68.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ire != None:
      oprot.writeFieldBegin('ire', TType.STRUCT, 1)
      self.ire.write(oprot)
      oprot.writeFieldEnd()
    if self.nfe != None:
      oprot.writeFieldBegin('nfe', TType.STRUCT, 2)
      self.nfe.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_slice_by_names_args(object):
  """
  Attributes:
   - tablename
   - key
   - columnParent
   - columnNames
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tablename', None, None, ), # 1
    (2, TType.STRING, 'key', None, None, ), # 2
    (3, TType.STRING, 'columnParent', None, None, ), # 3
    (4, TType.LIST, 'columnNames', (TType.STRING,None), None, ), # 4
  )

  def __init__(self, tablename=None, key=None, columnParent=None, columnNames=None,):
    self.tablename = tablename
    self.key = key
    self.columnParent = columnParent
    self.columnNames = columnNames

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tablename = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.key = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.columnParent = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.columnNames = []
          (_etype72, _size69) = iprot.readListBegin()
          for _i73 in xrange(_size69):
            _elem74 = iprot.readString();
            self.columnNames.append(_elem74)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_slice_by_names_args')
    if self.tablename != None:
      oprot.writeFieldBegin('tablename', TType.STRING, 1)
      oprot.writeString(self.tablename)
      oprot.writeFieldEnd()
    if self.key != None:
      oprot.writeFieldBegin('key', TType.STRING, 2)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.columnParent != None:
      oprot.writeFieldBegin('columnParent', TType.STRING, 3)
      oprot.writeString(self.columnParent)
      oprot.writeFieldEnd()
    if self.columnNames != None:
      oprot.writeFieldBegin('columnNames', TType.LIST, 4)
      oprot.writeListBegin(TType.STRING, len(self.columnNames))
      for iter75 in self.columnNames:
        oprot.writeString(iter75)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_slice_by_names_result(object):
  """
  Attributes:
   - success
   - ire
   - nfe
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(column_t, column_t.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ire', (InvalidRequestException, InvalidRequestException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'nfe', (NotFoundException, NotFoundException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ire=None, nfe=None,):
    self.success = success
    self.ire = ire
    self.nfe = nfe

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype79, _size76) = iprot.readListBegin()
          for _i80 in xrange(_size76):
            _elem81 = column_t()
            _elem81.read(iprot)
            self.success.append(_elem81)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ire = InvalidRequestException()
          self.ire.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.nfe = NotFoundException()
          self.nfe.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_slice_by_names_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter82 in self.success:
        iter82.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ire != None:
      oprot.writeFieldBegin('ire', TType.STRUCT, 1)
      self.ire.write(oprot)
      oprot.writeFieldEnd()
    if self.nfe != None:
      oprot.writeFieldBegin('nfe', TType.STRUCT, 2)
      self.nfe.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_slice_from_args(object):
  """
  Attributes:
   - tablename
   - key
   - columnParent
   - isAscending
   - count
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tablename', None, None, ), # 1
    (2, TType.STRING, 'key', None, None, ), # 2
    (3, TType.STRING, 'columnParent', None, None, ), # 3
    (4, TType.BOOL, 'isAscending', None, None, ), # 4
    (5, TType.I32, 'count', None, None, ), # 5
  )

  def __init__(self, tablename=None, key=None, columnParent=None, isAscending=None, count=None,):
    self.tablename = tablename
    self.key = key
    self.columnParent = columnParent
    self.isAscending = isAscending
    self.count = count

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tablename = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.key = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.columnParent = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.isAscending = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.count = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_slice_from_args')
    if self.tablename != None:
      oprot.writeFieldBegin('tablename', TType.STRING, 1)
      oprot.writeString(self.tablename)
      oprot.writeFieldEnd()
    if self.key != None:
      oprot.writeFieldBegin('key', TType.STRING, 2)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.columnParent != None:
      oprot.writeFieldBegin('columnParent', TType.STRING, 3)
      oprot.writeString(self.columnParent)
      oprot.writeFieldEnd()
    if self.isAscending != None:
      oprot.writeFieldBegin('isAscending', TType.BOOL, 4)
      oprot.writeBool(self.isAscending)
      oprot.writeFieldEnd()
    if self.count != None:
      oprot.writeFieldBegin('count', TType.I32, 5)
      oprot.writeI32(self.count)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_slice_from_result(object):
  """
  Attributes:
   - success
   - ire
   - nfe
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(column_t, column_t.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ire', (InvalidRequestException, InvalidRequestException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'nfe', (NotFoundException, NotFoundException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ire=None, nfe=None,):
    self.success = success
    self.ire = ire
    self.nfe = nfe

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype86, _size83) = iprot.readListBegin()
          for _i87 in xrange(_size83):
            _elem88 = column_t()
            _elem88.read(iprot)
            self.success.append(_elem88)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ire = InvalidRequestException()
          self.ire.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.nfe = NotFoundException()
          self.nfe.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_slice_from_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter89 in self.success:
        iter89.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ire != None:
      oprot.writeFieldBegin('ire', TType.STRUCT, 1)
      self.ire.write(oprot)
      oprot.writeFieldEnd()
    if self.nfe != None:
      oprot.writeFieldBegin('nfe', TType.STRUCT, 2)
      self.nfe.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_column_args(object):
  """
  Attributes:
   - tablename
   - key
   - columnPath
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tablename', None, None, ), # 1
    (2, TType.STRING, 'key', None, None, ), # 2
    (3, TType.STRING, 'columnPath', None, None, ), # 3
  )

  def __init__(self, tablename=None, key=None, columnPath=None,):
    self.tablename = tablename
    self.key = key
    self.columnPath = columnPath

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tablename = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.key = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.columnPath = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_column_args')
    if self.tablename != None:
      oprot.writeFieldBegin('tablename', TType.STRING, 1)
      oprot.writeString(self.tablename)
      oprot.writeFieldEnd()
    if self.key != None:
      oprot.writeFieldBegin('key', TType.STRING, 2)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.columnPath != None:
      oprot.writeFieldBegin('columnPath', TType.STRING, 3)
      oprot.writeString(self.columnPath)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_column_result(object):
  """
  Attributes:
   - success
   - ire
   - nfe
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (column_t, column_t.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ire', (InvalidRequestException, InvalidRequestException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'nfe', (NotFoundException, NotFoundException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ire=None, nfe=None,):
    self.success = success
    self.ire = ire
    self.nfe = nfe

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = column_t()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ire = InvalidRequestException()
          self.ire.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.nfe = NotFoundException()
          self.nfe.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_column_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ire != None:
      oprot.writeFieldBegin('ire', TType.STRUCT, 1)
      self.ire.write(oprot)
      oprot.writeFieldEnd()
    if self.nfe != None:
      oprot.writeFieldBegin('nfe', TType.STRUCT, 2)
      self.nfe.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_column_count_args(object):
  """
  Attributes:
   - tablename
   - key
   - columnParent
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tablename', None, None, ), # 1
    (2, TType.STRING, 'key', None, None, ), # 2
    (3, TType.STRING, 'columnParent', None, None, ), # 3
  )

  def __init__(self, tablename=None, key=None, columnParent=None,):
    self.tablename = tablename
    self.key = key
    self.columnParent = columnParent

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tablename = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.key = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.columnParent = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_column_count_args')
    if self.tablename != None:
      oprot.writeFieldBegin('tablename', TType.STRING, 1)
      oprot.writeString(self.tablename)
      oprot.writeFieldEnd()
    if self.key != None:
      oprot.writeFieldBegin('key', TType.STRING, 2)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.columnParent != None:
      oprot.writeFieldBegin('columnParent', TType.STRING, 3)
      oprot.writeString(self.columnParent)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_column_count_result(object):
  """
  Attributes:
   - success
   - ire
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'ire', (InvalidRequestException, InvalidRequestException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ire=None,):
    self.success = success
    self.ire = ire

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ire = InvalidRequestException()
          self.ire.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_column_count_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.ire != None:
      oprot.writeFieldBegin('ire', TType.STRUCT, 1)
      self.ire.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class insert_args(object):
  """
  Attributes:
   - tablename
   - key
   - columnPath
   - cellData
   - timestamp
   - block_for
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tablename', None, None, ), # 1
    (2, TType.STRING, 'key', None, None, ), # 2
    (3, TType.STRING, 'columnPath', None, None, ), # 3
    (4, TType.STRING, 'cellData', None, None, ), # 4
    (5, TType.I64, 'timestamp', None, None, ), # 5
    (6, TType.I32, 'block_for', None, 0, ), # 6
  )

  def __init__(self, tablename=None, key=None, columnPath=None, cellData=None, timestamp=None, block_for=thrift_spec[6][4],):
    self.tablename = tablename
    self.key = key
    self.columnPath = columnPath
    self.cellData = cellData
    self.timestamp = timestamp
    self.block_for = block_for

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tablename = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.key = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.columnPath = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.cellData = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.block_for = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('insert_args')
    if self.tablename != None:
      oprot.writeFieldBegin('tablename', TType.STRING, 1)
      oprot.writeString(self.tablename)
      oprot.writeFieldEnd()
    if self.key != None:
      oprot.writeFieldBegin('key', TType.STRING, 2)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.columnPath != None:
      oprot.writeFieldBegin('columnPath', TType.STRING, 3)
      oprot.writeString(self.columnPath)
      oprot.writeFieldEnd()
    if self.cellData != None:
      oprot.writeFieldBegin('cellData', TType.STRING, 4)
      oprot.writeString(self.cellData)
      oprot.writeFieldEnd()
    if self.timestamp != None:
      oprot.writeFieldBegin('timestamp', TType.I64, 5)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.block_for != None:
      oprot.writeFieldBegin('block_for', TType.I32, 6)
      oprot.writeI32(self.block_for)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class insert_result(object):
  """
  Attributes:
   - ire
   - ue
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ire', (InvalidRequestException, InvalidRequestException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ue', (UnavailableException, UnavailableException.thrift_spec), None, ), # 2
  )

  def __init__(self, ire=None, ue=None,):
    self.ire = ire
    self.ue = ue

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ire = InvalidRequestException()
          self.ire.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ue = UnavailableException()
          self.ue.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('insert_result')
    if self.ire != None:
      oprot.writeFieldBegin('ire', TType.STRUCT, 1)
      self.ire.write(oprot)
      oprot.writeFieldEnd()
    if self.ue != None:
      oprot.writeFieldBegin('ue', TType.STRUCT, 2)
      self.ue.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class batch_insert_args(object):
  """
  Attributes:
   - batchMutation
   - block_for
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'batchMutation', (batch_mutation_t, batch_mutation_t.thrift_spec), None, ), # 1
    (2, TType.I32, 'block_for', None, 0, ), # 2
  )

  def __init__(self, batchMutation=None, block_for=thrift_spec[2][4],):
    self.batchMutation = batchMutation
    self.block_for = block_for

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.batchMutation = batch_mutation_t()
          self.batchMutation.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.block_for = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('batch_insert_args')
    if self.batchMutation != None:
      oprot.writeFieldBegin('batchMutation', TType.STRUCT, 1)
      self.batchMutation.write(oprot)
      oprot.writeFieldEnd()
    if self.block_for != None:
      oprot.writeFieldBegin('block_for', TType.I32, 2)
      oprot.writeI32(self.block_for)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class batch_insert_result(object):
  """
  Attributes:
   - ire
   - ue
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ire', (InvalidRequestException, InvalidRequestException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ue', (UnavailableException, UnavailableException.thrift_spec), None, ), # 2
  )

  def __init__(self, ire=None, ue=None,):
    self.ire = ire
    self.ue = ue

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ire = InvalidRequestException()
          self.ire.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ue = UnavailableException()
          self.ue.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('batch_insert_result')
    if self.ire != None:
      oprot.writeFieldBegin('ire', TType.STRUCT, 1)
      self.ire.write(oprot)
      oprot.writeFieldEnd()
    if self.ue != None:
      oprot.writeFieldBegin('ue', TType.STRUCT, 2)
      self.ue.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class remove_args(object):
  """
  Attributes:
   - tablename
   - key
   - columnPathOrParent
   - timestamp
   - block_for
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tablename', None, None, ), # 1
    (2, TType.STRING, 'key', None, None, ), # 2
    (3, TType.STRING, 'columnPathOrParent', None, None, ), # 3
    (4, TType.I64, 'timestamp', None, None, ), # 4
    (5, TType.I32, 'block_for', None, 0, ), # 5
  )

  def __init__(self, tablename=None, key=None, columnPathOrParent=None, timestamp=None, block_for=thrift_spec[5][4],):
    self.tablename = tablename
    self.key = key
    self.columnPathOrParent = columnPathOrParent
    self.timestamp = timestamp
    self.block_for = block_for

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tablename = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.key = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.columnPathOrParent = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.block_for = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('remove_args')
    if self.tablename != None:
      oprot.writeFieldBegin('tablename', TType.STRING, 1)
      oprot.writeString(self.tablename)
      oprot.writeFieldEnd()
    if self.key != None:
      oprot.writeFieldBegin('key', TType.STRING, 2)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.columnPathOrParent != None:
      oprot.writeFieldBegin('columnPathOrParent', TType.STRING, 3)
      oprot.writeString(self.columnPathOrParent)
      oprot.writeFieldEnd()
    if self.timestamp != None:
      oprot.writeFieldBegin('timestamp', TType.I64, 4)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.block_for != None:
      oprot.writeFieldBegin('block_for', TType.I32, 5)
      oprot.writeI32(self.block_for)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class remove_result(object):
  """
  Attributes:
   - ire
   - ue
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ire', (InvalidRequestException, InvalidRequestException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ue', (UnavailableException, UnavailableException.thrift_spec), None, ), # 2
  )

  def __init__(self, ire=None, ue=None,):
    self.ire = ire
    self.ue = ue

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ire = InvalidRequestException()
          self.ire.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ue = UnavailableException()
          self.ue.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('remove_result')
    if self.ire != None:
      oprot.writeFieldBegin('ire', TType.STRUCT, 1)
      self.ire.write(oprot)
      oprot.writeFieldEnd()
    if self.ue != None:
      oprot.writeFieldBegin('ue', TType.STRUCT, 2)
      self.ue.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_columns_since_args(object):
  """
  Attributes:
   - tablename
   - key
   - columnParent
   - timeStamp
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tablename', None, None, ), # 1
    (2, TType.STRING, 'key', None, None, ), # 2
    (3, TType.STRING, 'columnParent', None, None, ), # 3
    (4, TType.I64, 'timeStamp', None, None, ), # 4
  )

  def __init__(self, tablename=None, key=None, columnParent=None, timeStamp=None,):
    self.tablename = tablename
    self.key = key
    self.columnParent = columnParent
    self.timeStamp = timeStamp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tablename = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.key = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.columnParent = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.timeStamp = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_columns_since_args')
    if self.tablename != None:
      oprot.writeFieldBegin('tablename', TType.STRING, 1)
      oprot.writeString(self.tablename)
      oprot.writeFieldEnd()
    if self.key != None:
      oprot.writeFieldBegin('key', TType.STRING, 2)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.columnParent != None:
      oprot.writeFieldBegin('columnParent', TType.STRING, 3)
      oprot.writeString(self.columnParent)
      oprot.writeFieldEnd()
    if self.timeStamp != None:
      oprot.writeFieldBegin('timeStamp', TType.I64, 4)
      oprot.writeI64(self.timeStamp)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_columns_since_result(object):
  """
  Attributes:
   - success
   - ire
   - nfe
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(column_t, column_t.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ire', (InvalidRequestException, InvalidRequestException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'nfe', (NotFoundException, NotFoundException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ire=None, nfe=None,):
    self.success = success
    self.ire = ire
    self.nfe = nfe

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype93, _size90) = iprot.readListBegin()
          for _i94 in xrange(_size90):
            _elem95 = column_t()
            _elem95.read(iprot)
            self.success.append(_elem95)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ire = InvalidRequestException()
          self.ire.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.nfe = NotFoundException()
          self.nfe.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_columns_since_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter96 in self.success:
        iter96.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ire != None:
      oprot.writeFieldBegin('ire', TType.STRUCT, 1)
      self.ire.write(oprot)
      oprot.writeFieldEnd()
    if self.nfe != None:
      oprot.writeFieldBegin('nfe', TType.STRUCT, 2)
      self.nfe.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_slice_super_args(object):
  """
  Attributes:
   - tablename
   - key
   - columnFamily
   - start
   - count
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tablename', None, None, ), # 1
    (2, TType.STRING, 'key', None, None, ), # 2
    (3, TType.STRING, 'columnFamily', None, None, ), # 3
    (4, TType.I32, 'start', None, -1, ), # 4
    (5, TType.I32, 'count', None, -1, ), # 5
  )

  def __init__(self, tablename=None, key=None, columnFamily=None, start=thrift_spec[4][4], count=thrift_spec[5][4],):
    self.tablename = tablename
    self.key = key
    self.columnFamily = columnFamily
    self.start = start
    self.count = count

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tablename = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.key = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.columnFamily = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.start = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.count = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_slice_super_args')
    if self.tablename != None:
      oprot.writeFieldBegin('tablename', TType.STRING, 1)
      oprot.writeString(self.tablename)
      oprot.writeFieldEnd()
    if self.key != None:
      oprot.writeFieldBegin('key', TType.STRING, 2)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.columnFamily != None:
      oprot.writeFieldBegin('columnFamily', TType.STRING, 3)
      oprot.writeString(self.columnFamily)
      oprot.writeFieldEnd()
    if self.start != None:
      oprot.writeFieldBegin('start', TType.I32, 4)
      oprot.writeI32(self.start)
      oprot.writeFieldEnd()
    if self.count != None:
      oprot.writeFieldBegin('count', TType.I32, 5)
      oprot.writeI32(self.count)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_slice_super_result(object):
  """
  Attributes:
   - success
   - ire
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(superColumn_t, superColumn_t.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ire', (InvalidRequestException, InvalidRequestException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ire=None,):
    self.success = success
    self.ire = ire

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype100, _size97) = iprot.readListBegin()
          for _i101 in xrange(_size97):
            _elem102 = superColumn_t()
            _elem102.read(iprot)
            self.success.append(_elem102)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ire = InvalidRequestException()
          self.ire.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_slice_super_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter103 in self.success:
        iter103.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ire != None:
      oprot.writeFieldBegin('ire', TType.STRUCT, 1)
      self.ire.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_slice_super_by_names_args(object):
  """
  Attributes:
   - tablename
   - key
   - columnFamily
   - superColumnNames
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tablename', None, None, ), # 1
    (2, TType.STRING, 'key', None, None, ), # 2
    (3, TType.STRING, 'columnFamily', None, None, ), # 3
    (4, TType.LIST, 'superColumnNames', (TType.STRING,None), None, ), # 4
  )

  def __init__(self, tablename=None, key=None, columnFamily=None, superColumnNames=None,):
    self.tablename = tablename
    self.key = key
    self.columnFamily = columnFamily
    self.superColumnNames = superColumnNames

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tablename = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.key = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.columnFamily = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.superColumnNames = []
          (_etype107, _size104) = iprot.readListBegin()
          for _i108 in xrange(_size104):
            _elem109 = iprot.readString();
            self.superColumnNames.append(_elem109)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_slice_super_by_names_args')
    if self.tablename != None:
      oprot.writeFieldBegin('tablename', TType.STRING, 1)
      oprot.writeString(self.tablename)
      oprot.writeFieldEnd()
    if self.key != None:
      oprot.writeFieldBegin('key', TType.STRING, 2)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.columnFamily != None:
      oprot.writeFieldBegin('columnFamily', TType.STRING, 3)
      oprot.writeString(self.columnFamily)
      oprot.writeFieldEnd()
    if self.superColumnNames != None:
      oprot.writeFieldBegin('superColumnNames', TType.LIST, 4)
      oprot.writeListBegin(TType.STRING, len(self.superColumnNames))
      for iter110 in self.superColumnNames:
        oprot.writeString(iter110)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_slice_super_by_names_result(object):
  """
  Attributes:
   - success
   - ire
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(superColumn_t, superColumn_t.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'ire', (InvalidRequestException, InvalidRequestException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ire=None,):
    self.success = success
    self.ire = ire

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype114, _size111) = iprot.readListBegin()
          for _i115 in xrange(_size111):
            _elem116 = superColumn_t()
            _elem116.read(iprot)
            self.success.append(_elem116)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ire = InvalidRequestException()
          self.ire.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_slice_super_by_names_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter117 in self.success:
        iter117.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ire != None:
      oprot.writeFieldBegin('ire', TType.STRUCT, 1)
      self.ire.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_superColumn_args(object):
  """
  Attributes:
   - tablename
   - key
   - superColumnPath
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tablename', None, None, ), # 1
    (2, TType.STRING, 'key', None, None, ), # 2
    (3, TType.STRING, 'superColumnPath', None, None, ), # 3
  )

  def __init__(self, tablename=None, key=None, superColumnPath=None,):
    self.tablename = tablename
    self.key = key
    self.superColumnPath = superColumnPath

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tablename = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.key = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.superColumnPath = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_superColumn_args')
    if self.tablename != None:
      oprot.writeFieldBegin('tablename', TType.STRING, 1)
      oprot.writeString(self.tablename)
      oprot.writeFieldEnd()
    if self.key != None:
      oprot.writeFieldBegin('key', TType.STRING, 2)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    if self.superColumnPath != None:
      oprot.writeFieldBegin('superColumnPath', TType.STRING, 3)
      oprot.writeString(self.superColumnPath)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_superColumn_result(object):
  """
  Attributes:
   - success
   - ire
   - nfe
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (superColumn_t, superColumn_t.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'ire', (InvalidRequestException, InvalidRequestException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'nfe', (NotFoundException, NotFoundException.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, ire=None, nfe=None,):
    self.success = success
    self.ire = ire
    self.nfe = nfe

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = superColumn_t()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ire = InvalidRequestException()
          self.ire.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.nfe = NotFoundException()
          self.nfe.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_superColumn_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.ire != None:
      oprot.writeFieldBegin('ire', TType.STRUCT, 1)
      self.ire.write(oprot)
      oprot.writeFieldEnd()
    if self.nfe != None:
      oprot.writeFieldBegin('nfe', TType.STRUCT, 2)
      self.nfe.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class batch_insert_superColumn_args(object):
  """
  Attributes:
   - batchMutationSuper
   - block_for
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'batchMutationSuper', (batch_mutation_super_t, batch_mutation_super_t.thrift_spec), None, ), # 1
    (2, TType.I32, 'block_for', None, 0, ), # 2
  )

  def __init__(self, batchMutationSuper=None, block_for=thrift_spec[2][4],):
    self.batchMutationSuper = batchMutationSuper
    self.block_for = block_for

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.batchMutationSuper = batch_mutation_super_t()
          self.batchMutationSuper.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.block_for = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('batch_insert_superColumn_args')
    if self.batchMutationSuper != None:
      oprot.writeFieldBegin('batchMutationSuper', TType.STRUCT, 1)
      self.batchMutationSuper.write(oprot)
      oprot.writeFieldEnd()
    if self.block_for != None:
      oprot.writeFieldBegin('block_for', TType.I32, 2)
      oprot.writeI32(self.block_for)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class batch_insert_superColumn_result(object):
  """
  Attributes:
   - ire
   - ue
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ire', (InvalidRequestException, InvalidRequestException.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'ue', (UnavailableException, UnavailableException.thrift_spec), None, ), # 2
  )

  def __init__(self, ire=None, ue=None,):
    self.ire = ire
    self.ue = ue

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ire = InvalidRequestException()
          self.ire.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ue = UnavailableException()
          self.ue.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('batch_insert_superColumn_result')
    if self.ire != None:
      oprot.writeFieldBegin('ire', TType.STRUCT, 1)
      self.ire.write(oprot)
      oprot.writeFieldEnd()
    if self.ue != None:
      oprot.writeFieldBegin('ue', TType.STRUCT, 2)
      self.ue.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_key_range_args(object):
  """
  Attributes:
   - tablename
   - columnFamilies
   - startWith
   - stopAt
   - maxResults
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tablename', None, None, ), # 1
    (2, TType.LIST, 'columnFamilies', (TType.STRING,None), [
    ], ), # 2
    (3, TType.STRING, 'startWith', None, "", ), # 3
    (4, TType.STRING, 'stopAt', None, "", ), # 4
    (5, TType.I32, 'maxResults', None, 1000, ), # 5
  )

  def __init__(self, tablename=None, columnFamilies=thrift_spec[2][4], startWith=thrift_spec[3][4], stopAt=thrift_spec[4][4], maxResults=thrift_spec[5][4],):
    self.tablename = tablename
    if columnFamilies is self.thrift_spec[2][4]:
      columnFamilies = [
    ]
    self.columnFamilies = columnFamilies
    self.startWith = startWith
    self.stopAt = stopAt
    self.maxResults = maxResults

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tablename = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.columnFamilies = []
          (_etype121, _size118) = iprot.readListBegin()
          for _i122 in xrange(_size118):
            _elem123 = iprot.readString();
            self.columnFamilies.append(_elem123)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.startWith = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.stopAt = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.maxResults = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_key_range_args')
    if self.tablename != None:
      oprot.writeFieldBegin('tablename', TType.STRING, 1)
      oprot.writeString(self.tablename)
      oprot.writeFieldEnd()
    if self.columnFamilies != None:
      oprot.writeFieldBegin('columnFamilies', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.columnFamilies))
      for iter124 in self.columnFamilies:
        oprot.writeString(iter124)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.startWith != None:
      oprot.writeFieldBegin('startWith', TType.STRING, 3)
      oprot.writeString(self.startWith)
      oprot.writeFieldEnd()
    if self.stopAt != None:
      oprot.writeFieldBegin('stopAt', TType.STRING, 4)
      oprot.writeString(self.stopAt)
      oprot.writeFieldEnd()
    if self.maxResults != None:
      oprot.writeFieldBegin('maxResults', TType.I32, 5)
      oprot.writeI32(self.maxResults)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_key_range_result(object):
  """
  Attributes:
   - success
   - ire
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'ire', (InvalidRequestException, InvalidRequestException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, ire=None,):
    self.success = success
    self.ire = ire

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype128, _size125) = iprot.readListBegin()
          for _i129 in xrange(_size125):
            _elem130 = iprot.readString();
            self.success.append(_elem130)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.ire = InvalidRequestException()
          self.ire.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_key_range_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter131 in self.success:
        oprot.writeString(iter131)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ire != None:
      oprot.writeFieldBegin('ire', TType.STRUCT, 1)
      self.ire.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getStringProperty_args(object):
  """
  Attributes:
   - propertyName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'propertyName', None, None, ), # 1
  )

  def __init__(self, propertyName=None,):
    self.propertyName = propertyName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.propertyName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getStringProperty_args')
    if self.propertyName != None:
      oprot.writeFieldBegin('propertyName', TType.STRING, 1)
      oprot.writeString(self.propertyName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getStringProperty_result(object):
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getStringProperty_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getStringListProperty_args(object):
  """
  Attributes:
   - propertyName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'propertyName', None, None, ), # 1
  )

  def __init__(self, propertyName=None,):
    self.propertyName = propertyName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.propertyName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getStringListProperty_args')
    if self.propertyName != None:
      oprot.writeFieldBegin('propertyName', TType.STRING, 1)
      oprot.writeString(self.propertyName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getStringListProperty_result(object):
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype135, _size132) = iprot.readListBegin()
          for _i136 in xrange(_size132):
            _elem137 = iprot.readString();
            self.success.append(_elem137)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getStringListProperty_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter138 in self.success:
        oprot.writeString(iter138)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class describeTable_args(object):
  """
  Attributes:
   - tableName
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tableName', None, None, ), # 1
  )

  def __init__(self, tableName=None,):
    self.tableName = tableName

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tableName = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('describeTable_args')
    if self.tableName != None:
      oprot.writeFieldBegin('tableName', TType.STRING, 1)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class describeTable_result(object):
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('describeTable_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class executeQuery_args(object):
  """
  Attributes:
   - query
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'query', None, None, ), # 1
  )

  def __init__(self, query=None,):
    self.query = query

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.query = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('executeQuery_args')
    if self.query != None:
      oprot.writeFieldBegin('query', TType.STRING, 1)
      oprot.writeString(self.query)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class executeQuery_result(object):
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (CqlResult_t, CqlResult_t.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = CqlResult_t()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('executeQuery_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)


